import os
from typer.testing import CliRunner

import end_to_end_utils

qroma_cli_module = __import__("qroma-cli")
qroma_app = qroma_cli_module.app

runner = CliRunner()


def _assert_project_created(project_id):
    test_user_qroma_dir = end_to_end_utils.get_test_user_qroma_dir()
    expected_project_location = os.path.join(test_user_qroma_dir, project_id)
    assert os.path.isdir(expected_project_location)


def _assert_project_has_compiled_pb(project_id):
    qroma_receipt_location = end_to_end_utils.get_pb_build_compiled_by_qroma_receipt_location(project_id)
    assert os.path.isfile(qroma_receipt_location)

    expected_compile_message = "Protobuf files compiled/generated by 'docker-protobuf-compile' using docker image qroma-protobuf-compiler"
    assert end_to_end_utils.check_file_contains_string(qroma_receipt_location, expected_compile_message), \
        f"Could not find {expected_compile_message} in file at '{qroma_receipt_location}'"


def _assert_project_has_compiled_firmware(project_id):
    expected_min_file_size = 300_000
    firmware_out_locations = end_to_end_utils.get_firmware_build_output_bin_file_locations(project_id)
    for firmware_out_location in firmware_out_locations:
        assert os.path.isfile(firmware_out_location)

        actual_file_size = os.path.getsize(firmware_out_location)
        assert actual_file_size >= expected_min_file_size, \
            f"Filesize requirement not met ({expected_min_file_size} vs. {actual_file_size} for file at '{firmware_out_location}'"



def xtest_create_project_from_template():
    # arrange
    project_id = end_to_end_utils.create_project_id()
    project_handle = ":" + project_id

    # act
    runner.invoke(qroma_app, ["new", project_handle])
    print(project_id)

    # assert
    _assert_project_created(project_id)


def xtest_create_project_and_compile_pb_step():
    # arrange
    project_id = end_to_end_utils.create_project_id()
    project_handle = ":" + project_id

    # act
    runner.invoke(qroma_app, ["new", project_handle])
    runner.invoke(qroma_app, ["pb", "build", project_handle])

    # assert
    _assert_project_created(project_id)
    _assert_project_has_compiled_pb(project_id)


def test_create_project_and_compile_pb_and_firmware_steps():
    # arrange
    project_id = end_to_end_utils.create_project_id()
    project_handle = ":" + project_id

    # act
    runner.invoke(qroma_app, ["new", project_handle])
    runner.invoke(qroma_app, ["pb", "build", project_handle])
    runner.invoke(qroma_app, ["firmware", "build", project_handle])

    # assert
    _assert_project_created(project_id)
    _assert_project_has_compiled_pb(project_id)
    _assert_project_has_compiled_firmware(project_id)

    # assert os.path.isdir(expected_project_location)
    #
    # qroma_receipt_location = end_to_end_utils.get_pb_build_compiled_by_qroma_receipt_location(project_id)
    # assert os.path.isfile(qroma_receipt_location)
    #
    # expected_compile_message = "Protobuf files compiled/generated by 'docker-protobuf-compile' using docker image qroma-protobuf-compiler"
    # assert end_to_end_utils.check_file_contains_string(qroma_receipt_location, expected_compile_message), \
    #     f"Could not find {expected_compile_message} in file at '{qroma_receipt_location}'"
    #
    # expected_min_file_size = 300_000
    # firmware_out_locations = end_to_end_utils.get_firmware_build_output_bin_file_locations(project_id)
    # for firmware_out_location in firmware_out_locations:
    #     assert os.path.isfile(firmware_out_location)
    #
    #     actual_file_size = os.path.getsize(firmware_out_location)
    #     assert actual_file_size >= expected_min_file_size, \
    #         f"Filesize requirement not met ({expected_min_file_size} vs. {actual_file_size} for file at '{firmware_out_location}'"


def xtest_create_project_with_full_build_and_get_it_running_in_browser():
    # arrange
    project_id = end_to_end_utils.create_project_id()
    project_handle = ":" + project_id
    # test_user_qroma_dir = end_to_end_utils.get_test_user_qroma_dir()
    # expected_project_location = os.path.join(test_user_qroma_dir, project_id)

    # act
    runner.invoke(qroma_app, ["new", project_handle, "--full-build"])

    # assert
    _assert_project_created(project_id)
    _assert_project_has_compiled_pb(project_id)
    _assert_project_has_compiled_firmware(project_id)

    # assert os.path.isdir(expected_project_location)


def xtest_create_project_by_steps_and_get_it_running_in_browser():
    # arrange
    project_id = end_to_end_utils.create_project_id()
    project_handle = ":" + project_id
    # test_user_qroma_dir = end_to_end_utils.get_test_user_qroma_dir()
    # expected_project_location = os.path.join(test_user_qroma_dir, project_id)

    # act
    runner.invoke(qroma_app, ["new", project_handle])
    runner.invoke(qroma_app, ["pb", "build", project_handle])
    runner.invoke(qroma_app, ["firmware", "build", project_handle])
    runner.invoke(qroma_app, ["site", "build", project_handle])

    # assert
    _assert_project_created(project_id)
    _assert_project_has_compiled_pb(project_id)
    _assert_project_has_compiled_firmware(project_id)


    # assert os.path.isdir(expected_project_location)
    #
    # qroma_receipt_location = end_to_end_utils.get_pb_build_compiled_by_qroma_receipt_location(project_id)
    # assert os.path.isfile(qroma_receipt_location)
    #
    # expected_compile_message = "Protobuf files compiled/generated by 'docker-protobuf-compile' using docker image qroma-protobuf-compiler"
    # assert end_to_end_utils.check_file_contains_string(qroma_receipt_location, expected_compile_message), \
    #     f"Could not find {expected_compile_message} in file at '{qroma_receipt_location}'"
    #
    # expected_min_file_size = 300_000
    # firmware_out_locations = end_to_end_utils.get_firmware_build_output_bin_file_locations(project_id)
    # for firmware_out_location in firmware_out_locations:
    #     assert os.path.isfile(firmware_out_location)
    #
    #     actual_file_size = os.path.getsize(firmware_out_location)
    #     assert actual_file_size >= expected_min_file_size, \
    #         f"Filesize requirement not met ({expected_min_file_size} vs. {actual_file_size} for file at '{firmware_out_location}'"