import os
import pytest
from typer.testing import CliRunner

import end_to_end_utils
import end_to_end_checks

qroma_cli_module = __import__("qroma-cli")
qroma_app = qroma_cli_module.app

runner = CliRunner()


def _assert_project_created(project_id):
    test_user_qroma_dir = end_to_end_utils.get_test_user_qroma_dir()
    expected_project_location = os.path.join(test_user_qroma_dir, project_id)
    assert os.path.isdir(expected_project_location)


def _assert_project_has_compiled_pb(project_id):
    qroma_receipt_location = end_to_end_utils.get_pb_build_compiled_by_qroma_receipt_location(project_id)
    assert os.path.isfile(qroma_receipt_location)

    expected_compile_message = "Protobuf files compiled/generated by 'docker-protobuf-compile' using docker image qroma-project-generator-tools"
    assert end_to_end_checks.check_file_contains_string(qroma_receipt_location, expected_compile_message), \
        f"Could not find {expected_compile_message} in file at '{qroma_receipt_location}'"


def _assert_project_has_compiled_firmware(project_id):
    expected_min_file_size = 300_000
    firmware_out_locations = end_to_end_utils.get_firmware_build_output_bin_file_locations(project_id)
    for firmware_out_location in firmware_out_locations:
        assert os.path.isfile(firmware_out_location)

        actual_file_size = os.path.getsize(firmware_out_location)
        assert actual_file_size >= expected_min_file_size, \
            f"Filesize requirement not met ({expected_min_file_size} vs. {actual_file_size} for file at '{firmware_out_location}'"


def _assert_has_node_modules_directory(project_id):
    expected_site_node_modules_location = end_to_end_utils.get_site_build_output_node_modules_dir_location(project_id)
    assert os.path.isdir(expected_site_node_modules_location)


def _assert_http_server_is_running(server_url, project_id):
    has_strings = end_to_end_checks.check_url_content_has_strings(server_url, ["Docusaurus", project_id])
    assert has_strings


def _assert_has_static_dir_qroma_firmware_files(server_url, project_id):
    firmwaredirs_boardnames_and_chip_families = [
        ("esp32dev", "esp32", "ESP32"),
        ("tinypico", "um_tinypico", "ESP32"),
        ("adafruit_qtpy_esp32c3", "adafruit_qtpy_esp32c3", "ESP32-C3"),
    ]

    firmware_url_root = f"{server_url}/{project_id}/qroma/versions/0.1.0/firmware"
    expected_firmware_min_size = 380000

    for firmwaredir, board_name, chip_family in firmwaredirs_boardnames_and_chip_families:
        firmware_filename = f"{project_id}-firmware-{board_name}.bin"
        manifest_filename = f"{project_id}-manifest-{board_name}.json"

        firmware_url = f"{firmware_url_root}/{firmwaredir}/{firmware_filename}"
        content_and_size_check = end_to_end_checks.check_url_content_exists_with_size(firmware_url, expected_firmware_min_size)
        assert content_and_size_check

        manifest_url = f"{firmware_url_root}/{firmwaredir}/{manifest_filename}"
        manifest_content_check = end_to_end_checks.check_url_content_has_strings(manifest_url, [
            f'"chipFamily": "{chip_family}"',
            f'"name": "{project_id}"',
        ])
        assert manifest_content_check




@pytest.fixture
def project_id():
    project_id_value = end_to_end_utils.create_project_id()
    # project_id_value = "test-project-2024-01-14.112915.629"
    return project_id_value


def _test_create_project_from_template(project_id):
    # arrange
    project_handle = ":" + project_id

    # act
    ex = runner.invoke(qroma_app, ["new", project_handle])
    print(project_id)

    # assert
    if ex.exception is not None:
        print("CREATE NEW RESULT HAS EXCEPTION.")
        print("DO YOU NEED TO CLEAR THE project_template_resources FOLDER DUE TO ZIP/HASH MISMATCH?")
        print("IS DOCKER CONTAINER RUNNING?")
    _assert_project_created(project_id)


def _test_pb_compile_without_docker_running_and_report_docker_service_not_running(project_id):
    # arrange
    project_handle = ":" + project_id

    exception_triggered = False

    # act
    _test_create_project_from_template(project_id)
    ex = runner.invoke(qroma_app, ["pb", "build", project_handle])
    if ex.exception is not None:
        exception_triggered = True

    # assert
    assert exception_triggered == True
    assert "Error running docker command" in ex.exception.args[0]
    assert "Cannot connect to the Docker daemon" in ex.exception.args[0]


def _test_create_project_and_compile_pb_step(project_id):
    # arrange
    project_handle = ":" + project_id

    # act
    _test_create_project_from_template(project_id)
    build_result = runner.invoke(qroma_app, ["pb", "build", project_handle])

    # assert
    if build_result.exception is not None:
        print("BUILD RESULT HAS EXCEPTION. IS DOCKER CONTAINER RUNNING?")

    assert build_result.exception is None
    _assert_project_has_compiled_pb(project_id)


def _test_create_project_and_compile_pb_and_firmware_steps(project_id):
    # arrange
    project_handle = ":" + project_id

    # act
    _test_create_project_and_compile_pb_step(project_id)
    runner.invoke(qroma_app, ["firmware", "build", project_handle])


    # assert
    # _assert_project_created(project_id)
    # _assert_project_has_compiled_pb(project_id)
    _assert_project_has_compiled_firmware(project_id)


def _test_create_project_with_full_build_and_get_it_running_in_browser(project_id):
    # arrange
    project_handle = ":" + project_id

    # act
    runner.invoke(qroma_app, ["new", project_handle, "--full-build"])

    # assert
    _assert_project_created(project_id)
    _assert_project_has_compiled_pb(project_id)
    _assert_project_has_compiled_firmware(project_id)

    _assert_has_node_modules_directory(project_id)
    _assert_has_static_dir_qroma_firmware_files(project_id)


_test_server_host: end_to_end_utils.WebServerTestHost | None = None


@pytest.fixture
def server_fixture():
    global _test_server_host

    # startup code
    _test_server_host = end_to_end_utils.WebServerTestHost()

    yield

    # cleanup code
    _test_server_host.stop_server()


@pytest.mark.usefixtures('server_fixture')
def test_create_project_by_steps_and_get_it_running_in_browser(project_id):
    # arrange
    project_handle = ":" + project_id
    server_port = 8722

    # act
    _test_create_project_and_compile_pb_and_firmware_steps(project_id)
    build_result = runner.invoke(qroma_app, ["site", "build", project_handle])

    if build_result.exit_code != 0:
        print("------------------------------------")
        print("BUILD OUTPUT")
        print(build_result.output)
        print("------------------------------------")
        print("BUILD EXCEPTION")
        print(build_result.exception)
        print("------------------------------------")
        print("BUILD ERROR")
        print(build_result.stderr)
        print("------------------------------------")

        assert build_result.exit_code == 0

    if _test_server_host is None:
        raise Exception("Fixture didn't set up host for test")

    _test_server_host.init(project_id, server_port)
    _test_server_host.start_server()
    _test_server_host.wait_for_responsiveness(120)

    server_root = _test_server_host.server_root

    # assert
    _assert_has_node_modules_directory(project_id)
    _assert_http_server_is_running(server_root, project_id)

    _assert_has_static_dir_qroma_firmware_files(server_root, project_id)

    # cleanup
    _test_server_host.stop_server()

