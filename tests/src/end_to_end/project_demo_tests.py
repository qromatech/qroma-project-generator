import os
import pytest
from typer.testing import CliRunner

import end_to_end_utils
import end_to_end_checks

qroma_cli_module = __import__("qroma-cli")
qroma_app = qroma_cli_module.app

runner = CliRunner()


def _assert_project_created(project_id):
    test_user_qroma_dir = end_to_end_utils.get_test_user_qroma_dir()
    expected_project_location = os.path.join(test_user_qroma_dir, project_id)
    assert os.path.isdir(expected_project_location)


def _assert_project_has_compiled_pb(project_id):
    qroma_receipt_location = end_to_end_utils.get_pb_build_compiled_by_qroma_receipt_location(project_id)
    assert os.path.isfile(qroma_receipt_location)

    expected_compile_message = "Protobuf files compiled/generated by 'docker-protobuf-compile' using docker image qroma-protobuf-compiler"
    assert end_to_end_checks.check_file_contains_string(qroma_receipt_location, expected_compile_message), \
        f"Could not find {expected_compile_message} in file at '{qroma_receipt_location}'"


def _assert_project_has_compiled_firmware(project_id):
    expected_min_file_size = 300_000
    firmware_out_locations = end_to_end_utils.get_firmware_build_output_bin_file_locations(project_id)
    for firmware_out_location in firmware_out_locations:
        assert os.path.isfile(firmware_out_location)

        actual_file_size = os.path.getsize(firmware_out_location)
        assert actual_file_size >= expected_min_file_size, \
            f"Filesize requirement not met ({expected_min_file_size} vs. {actual_file_size} for file at '{firmware_out_location}'"


def _assert_has_node_modules_directory(project_id):
    expected_site_node_modules_location = end_to_end_utils.get_site_build_output_node_modules_dir_location(project_id)
    assert os.path.isdir(expected_site_node_modules_location)


def _assert_http_server_is_running(server_url, project_id):
    has_strings = end_to_end_checks.check_url_content_has_strings(server_url, ["Docusaurus", project_id])
    assert has_strings


def _assert_has_static_dir_qroma_firmware_files(server_url, project_id):
    firmware_files_and_sizes = [
        ("boot_app0.bin", 5000),
        ("bootloader.bin", 15000),
        ("firmware.bin", 300000),
        ("partitions.bin", 2000),
    ]

    firmware_url_root = f"{server_url}/qroma/versions/0.1.0/firmware"
    for ff, f_size in firmware_files_and_sizes:
        firmware_url = f"{firmware_url_root}/{ff}"
        content_and_size_check = end_to_end_checks.check_url_content_exists_with_size(firmware_url, f_size)
        assert content_and_size_check

    manifest_url = f"{firmware_url_root}/manifest-firmware.json"
    manifest_content_check = end_to_end_checks.check_url_content_has_strings(manifest_url, [
        '"chipFamily": "ESP32"',
        f'"name": "{project_id}"',
    ])
    assert manifest_content_check


def _assert_has_qroma_loader_manifest(server_url, project_id):
    manifest_url = f"{server_url}/qroma/versions/manifest.json"
    manifest_content_check = end_to_end_checks.check_url_json_matches_dict(
        manifest_url,
        {
            "project_id": project_id,
            "version": "0.1.0",
            "qromaEsp32LoaderManifests": [
                {
                    "name": project_id,
                    "manifestPath": "/qroma/versions/0.1.0/firmware/manifest-firmware.json"
                }
            ]
        })

    assert manifest_content_check




@pytest.fixture
def project_id():
    project_id_value = end_to_end_utils.create_project_id()
    return project_id_value


def xtest_create_project_from_template(project_id):
    # arrange
    project_handle = ":" + project_id

    # act
    runner.invoke(qroma_app, ["new", project_handle])
    print(project_id)

    # assert
    _assert_project_created(project_id)


def xtest_pb_compile_without_docker_running_and_report_docker_service_not_running(project_id):
    # arrange
    project_handle = ":" + project_id

    exception_triggered = False

    # act
    xtest_create_project_from_template(project_id)
    ex = runner.invoke(qroma_app, ["pb", "build", project_handle])
    if ex.exception is not None:
        exception_triggered = True

    # assert
    assert exception_triggered == True
    assert "Error running docker command" in ex.exception.args[0]
    assert "Cannot connect to the Docker daemon" in ex.exception.args[0]


def xtest_create_project_and_compile_pb_step(project_id):
    # arrange
    project_handle = ":" + project_id

    # act
    xtest_create_project_from_template(project_id)
    build_result = runner.invoke(qroma_app, ["pb", "build", project_handle])

    # assert
    if build_result.exception is not None:
        print("BUILD RESULT HAS EXCEPTION. IS DOCKER CONTAINER RUNNING?")

    assert build_result.exception is None
    _assert_project_has_compiled_pb(project_id)


def xtest_create_project_and_compile_pb_and_firmware_steps(project_id):
    # arrange
    project_handle = ":" + project_id

    # act
    xtest_create_project_and_compile_pb_step(project_id)
    runner.invoke(qroma_app, ["firmware", "build", project_handle])


    # assert
    # _assert_project_created(project_id)
    # _assert_project_has_compiled_pb(project_id)
    _assert_project_has_compiled_firmware(project_id)


def xtest_create_project_with_full_build_and_get_it_running_in_browser(project_id):
    # arrange
    project_handle = ":" + project_id

    # act
    runner.invoke(qroma_app, ["new", project_handle, "--full-build"])

    # assert
    _assert_project_created(project_id)
    _assert_project_has_compiled_pb(project_id)
    _assert_project_has_compiled_firmware(project_id)

    _assert_has_node_modules_directory(project_id)
    _assert_has_static_dir_qroma_firmware_files(project_id)
    _assert_has_qroma_loader_manifest(project_id)


_test_server_host: end_to_end_utils.WebServerTestHost | None = None


@pytest.fixture
def server_fixture():
    global _test_server_host

    # startup code
    _test_server_host = end_to_end_utils.WebServerTestHost()

    yield

    # cleanup code
    _test_server_host.stop_server()


@pytest.mark.usefixtures('server_fixture')
def test_create_project_by_steps_and_get_it_running_in_browser(project_id):
    # arrange
    project_handle = ":" + project_id
    server_port = 8722

    # act
    xtest_create_project_and_compile_pb_and_firmware_steps(project_id)
    runner.invoke(qroma_app, ["site", "build", project_handle])

    if _test_server_host is None:
        raise Exception("Fixture didn't set up host for test")

    _test_server_host.init(project_id, server_port)
    _test_server_host.start_server()
    _test_server_host.wait_for_responsiveness(30)

    server_root = _test_server_host.server_root

    # assert
    # _assert_project_created(project_id)
    # _assert_project_has_compiled_pb(project_id)
    # _assert_project_has_compiled_firmware(project_id)

    _assert_has_node_modules_directory(project_id)
    _assert_http_server_is_running(server_root, project_id)

    _assert_has_static_dir_qroma_firmware_files(server_root, project_id)
    _assert_has_qroma_loader_manifest(server_root, project_id)

    # cleanup
    _test_server_host.stop_server()
